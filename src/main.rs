mod imu_tracker;

use core::time::Duration;
use std::num::NonZeroU32;
use std::time::Instant;
use anyhow::Result;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    nvs::EspDefaultNvsPartition,
    mqtt::client::*
};
use esp_idf_svc::hal::{
    delay::FreeRtos,
    gpio::{AnyOutputPin, PinDriver},
    i2c::{I2cConfig, I2cDriver},
    peripherals::Peripherals,
    units::FromValueType,
    //sys::EspError,
};
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};
use ssd1306::{prelude::*, I2CDisplayInterface, Ssd1306};
use embedded_graphics::{
    mono_font::{ascii::FONT_6X10, MonoTextStyleBuilder},
    pixelcolor::BinaryColor,
    prelude::*,
    text::{Baseline, Text},
};
use embedded_graphics::mono_font::MonoTextStyle;
use ssd1306::mode::BufferedGraphicsMode;
use esp_idf_svc::hal::spi::{SpiDeviceDriver, SpiDriverConfig};
use esp_idf_svc::hal::task::notification::Notification;
use esp_idf_svc::timer::EspTaskTimerService;
use imu_fusion::FusionVector;
use mpu9250::{ImuMeasurements, Mpu9250};
use crate::imu_tracker::ImuTracker;


// The constant `CONFIG` is auto-generated by `toml_config`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("1883")]
    mqtt_port: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    mqtt_id: &'static str,
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise, some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    let mut delay = FreeRtos;

    let i2c_config = I2cConfig::new().baudrate(400.kHz().into());
    let sda = peripherals.pins.gpio1;
    let scl = peripherals.pins.gpio0;
    let i2c = I2cDriver::new(peripherals.i2c0, sda, scl, &i2c_config)?;

    let sclk = peripherals.pins.gpio6;
    let miso = peripherals.pins.gpio2;
    let mosi = peripherals.pins.gpio7;
    let cs = PinDriver::output(peripherals.pins.gpio10)?;
    let spi_config = esp_idf_svc::hal::spi::config::Config::default().baudrate(1.MHz().into());
    let spi = SpiDeviceDriver::new_single(
        peripherals.spi2,
        sclk,
        mosi,
        Some(miso),
        Option::<AnyOutputPin>::None,
        &SpiDriverConfig::new(),
        &spi_config
    )?;
    let mut imu = Mpu9250::imu_default(spi, cs, &mut delay).expect("Could not init IMU!");
    let who_am_i = imu.who_am_i().expect("could not read WHO_AM_I");
    println!("WHO_AM_I: 0x{:x}", who_am_i);

    /*
    let acc_offsets: [f32; 3] = if let Ok(offsets) = imu.calibrate_at_rest(&mut delay) {
        offsets
    } else {
        log::warn!("Could not calibrate offsets!");
        [0f32; 3]
    };
    println!("Calibration is {:?}", acc_offsets);
    */

    let mut flag_serialize = PinDriver::output(peripherals.pins.gpio21)?;
    let mut flag_compute = PinDriver::output(peripherals.pins.gpio20)?;
    flag_serialize.set_low()?;
    flag_compute.set_low()?;

    let interface = I2CDisplayInterface::new(i2c);
    let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate180)
        .into_buffered_graphics_mode();
    display.init().unwrap();

    let text_style = MonoTextStyleBuilder::new()
        .font(&FONT_6X10)
        .text_color(BinaryColor::On)
        .build();
    
    let base_point = Point::zero();
    let msg = format!("SSID: {}", CONFIG.wifi_ssid);
    let mut base_point = display_msg(&mut display, text_style, msg, base_point);

    // Connect to the Wi-Fi network
    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs.clone()))?,
        sys_loop.clone(),
    )?;
    connect_wifi(&mut wifi)?;

    let msg = format!("IP: {}", wifi.wifi().sta_netif().get_ip_info().unwrap().ip);
    base_point.x = 0;
    let _base_point = display_msg(&mut display, text_style, msg, base_point);

    let mqtt_url: String = format!("mqtt://{}:{}", CONFIG.mqtt_host, CONFIG.mqtt_port);
    let (mut client, mut conn) = mqtt_create(&mqtt_url, CONFIG.mqtt_user, CONFIG.mqtt_pass)?;

    std::thread::Builder::new()
        .stack_size(8192)
        .spawn(move || {
            log::info!("MQTT Listening for messages");
            while let Ok(event) = conn.next() {
                log::info!("[Queue] Event: {}", event.payload());
            }
            log::info!("Connection closed");
        })
        .unwrap();

    // Configures the notification
    let notification = Notification::new();
    let notifier = notification.notifier();
    
    const IMU_SAMPLE_PERIOD: Duration = Duration::from_millis(5);
    let mut tracker = ImuTracker::new(IMU_SAMPLE_PERIOD, Instant::now());

    let timer_service = EspTaskTimerService::new().unwrap();
    let callback_timer = timer_service.timer(move || unsafe {
        notifier.notify_and_yield(NonZeroU32::new(1).unwrap());
    })?;
    callback_timer.every(IMU_SAMPLE_PERIOD)?;

    const REPORT_PERIOD: Duration = Duration::from_millis(200);
    const SKIP_COUNT: u32 = REPORT_PERIOD.as_millis() as u32 / (IMU_SAMPLE_PERIOD.as_millis() as u32);
    let mut skip = 0;

    let meas_topic = format!("{}/meas", CONFIG.mqtt_id);
    loop {
        notification.wait(esp_idf_svc::hal::delay::BLOCK);
        
        flag_compute.set_high().unwrap();        
        let all: ImuMeasurements<[f32;3]> = imu.all().expect("Unable to read from IMU!");
        let imu_gyro = FusionVector::new(all.gyro[0], all.gyro[1],all.gyro[2]) * (180f32 / std::f32::consts::PI);
        let imu_accel = FusionVector::new(all.accel[0],all.accel[1],all.accel[2]);
        tracker.update(imu_accel, imu_gyro);
        flag_compute.set_low().unwrap();

        let deviation = 100f32 * (tracker.latest_sampling_deviation() - 1f32);
        skip += 1;
        if skip == SKIP_COUNT {
            flag_serialize.set_high().unwrap();
            skip = 0;
            //println!("... px:{:+.3}, py:{:+.3}, pz:{:+.3}",
            //         pos_vector.x, pos_vector.y, pos_vector.z);
            let payload = format!("dt [ms]: {:.2}, pitch:{:+.1} roll:{:+.1} yaw:{:+.1} ae_x:{:+.3} ae.y:{:+.3} ae.z:{:+.3}",
                                  1000f32*tracker.latest_delta,
                     tracker.euler.angle.pitch, tracker.euler.angle.roll, tracker.euler.angle.yaw,
                     tracker.accel.x, tracker.accel.y, tracker.accel.z,
            );
            client.enqueue(&meas_topic, QoS::AtLeastOnce, false, payload.as_bytes())?;
            log::info!("dt: {:5.2}ms ({:.1}%), temp: {:.1}C",
                       1000f32*tracker.latest_delta, deviation, all.temp);
           flag_serialize.set_low().unwrap();
        }
    }
}

fn display_msg(display: &mut Ssd1306<I2CInterface<I2cDriver>, DisplaySize128x64, BufferedGraphicsMode<DisplaySize128x64>>,
               text_style: MonoTextStyle<BinaryColor>,
               msg: String,
               point: Point,
) -> Point {
    let t = Text::with_baseline(&msg, point, text_style, Baseline::Top);
    t.draw(display).unwrap();
    display.flush().unwrap();
    t.bounding_box().bottom_right().unwrap()
}


fn connect_wifi(wifi: &mut BlockingWifi<EspWifi<'static>>) -> Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: CONFIG.wifi_ssid.parse().unwrap(),
        password: CONFIG.wifi_psk.parse().unwrap(),
        auth_method: AuthMethod::WPA2Personal,
        ..Default::default()
    });
    wifi.set_configuration(&wifi_configuration)?;
    log::info!("CFG: {:?}", wifi_configuration);

    wifi.start()?;
    log::info!("Wifi started? {}", wifi.is_started()?);

    /* WiFi environment info
    let caps = wifi.get_capabilities()?;
    log::info!("Capabilities {:?}", caps);
    if let Ok(net) = wifi.scan() {
        for ap in net {
            log::info!("Available: {:?}", ap);
        }
    }
    */

    log::info!("Connecting to Wifi...");
    loop {
        match wifi.connect() {
            Ok(_) => break,
            Err(e) => {
                log::warn!("Could not connect ({:?})! Attempting again...", e);           
            }
        }
    }
    log::info!("Wifi connected");

    wifi.wait_netif_up()?;
    log::info!("Wifi netif up");

    Ok(())
}

fn mqtt_create(
    url: &str,
    client_id: &str,
    password: &str,
) -> Result<(EspMqttClient<'static>, EspMqttConnection)> {
    let (mqtt_client, mqtt_conn) = EspMqttClient::new(
        url,
        &MqttClientConfiguration {
            client_id: Some(client_id),
            password: Some(password),
            username: Some(client_id),
            ..Default::default()
        },
    )?;

    Ok((mqtt_client, mqtt_conn))
}
