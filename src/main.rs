use core::time::Duration;
use std::num::NonZeroU32;
use std::sync::mpsc::channel;
use std::time::Instant;

use anyhow::{anyhow, Result};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    nvs::EspDefaultNvsPartition,
    mqtt::client::*
};
use esp_idf_svc::hal::spi::{SpiDeviceDriver, SpiDriverConfig};
use esp_idf_svc::hal::task::notification::Notification;
use esp_idf_svc::hal::{
    delay::FreeRtos,
    gpio::{AnyOutputPin, PinDriver},
    peripherals::Peripherals,
    units::FromValueType,
    //sys::EspError,
    spi::config::Config as SpiConfig,
};
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};
use esp_idf_svc::timer::EspTaskTimerService;
use mpu9250::{ Mpu9250, MpuConfig };

use imu_fusion::{FusionMatrix, FusionVector};
mod imu_tracker;
use imu_tracker::ImuTracker;

mod analysis;
use analysis::{Analysis, MovementDirection};
mod state_machine;
use state_machine::{SensorFSM, ConnectionFSM, ConnectionStatus};

// The constant `CONFIG` is auto-generated by `toml_config`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("1883")]
    mqtt_port: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    mqtt_id: &'static str,
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise, some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let mut imu_state = SensorFSM::new();
    let mut link_state = ConnectionFSM::new();

    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    let mut delay = FreeRtos;

    let sclk = peripherals.pins.gpio6;
    let miso = peripherals.pins.gpio2;
    let mosi = peripherals.pins.gpio7;
    let cs = PinDriver::output(peripherals.pins.gpio10)?;
    imu_state.bootup_complete().map_err(|err| anyhow!("IMUError: {:?}", err))?;
    link_state.bootup_complete().map_err(|err| anyhow!("LinkError: {:?}", err))?;

    let spi = SpiDeviceDriver::new_single(
        peripherals.spi2,
        sclk,
        mosi,
        Some(miso),
        Option::<AnyOutputPin>::None,
        &SpiDriverConfig::new(),
        &SpiConfig::default().baudrate(1.MHz().into()),
    )?;
    let gyro_rate = mpu9250::GyroTempDataRate::DlpfConf(mpu9250::Dlpf::_0);
    let mut imu = Mpu9250::imu(
        spi,
        cs,
        &mut delay,
        MpuConfig::imu()
            .gyro_temp_data_rate(gyro_rate)
            .sample_rate_divisor(3)
    ).map_err(|err| anyhow!("IMUError: {:?}", err))?;

    let who_am_i = imu.who_am_i().map_err(|err| anyhow!("IMUError: {:?}", err))?;
    log::info!("WHO_AM_I: 0x{:x}", who_am_i);

    let mut flag_serialize = PinDriver::output(peripherals.pins.gpio21)?;
    let mut flag_acquire = PinDriver::output(peripherals.pins.gpio20)?;
    flag_serialize.set_low()?;
    flag_acquire.set_low()?;

    // Sets up periodic sampling notification
    let notification = Notification::new();
    let notifier = notification.notifier();
    const IMU_SAMPLE_PERIOD: Duration = Duration::from_millis(5);
    let timer_service = EspTaskTimerService::new()?;
    let callback_timer = timer_service.timer(move || unsafe {
        notifier.notify_and_yield(NonZeroU32::new(1).unwrap());
    })?;
    callback_timer.every(IMU_SAMPLE_PERIOD)?;

    /* Test calibration function. As expected, it cannot account for earth's gravity
    let offsets: [f32; 3] = imu.calibrate_at_rest(&mut delay).map_err(|err| anyhow!("Error: {:?}", err))?;
    println!("Offsets: {:?}", offsets);
    */
    let acc_misalignment = FusionMatrix::new(0.998154, 4.21399e-09, 1.36475e-09,
                                                        4.21466e-09, 0.997542, -2.99281e-09,
                                                        1.2859e-09, -3.01287e-09, 0.987841);
    let acc_offset = FusionVector::new(0.0246591f32, -0.00429982f32, 0.137597f32);
    let acc_sensitivity = FusionVector::ones();
    let gyr_offset = FusionVector::new(1.275, 1.902, -1.202);
    let mut tracker = ImuTracker::new(IMU_SAMPLE_PERIOD, Instant::now(), 2000.0f32,
                                      acc_misalignment, acc_sensitivity, acc_offset, gyr_offset);

    imu_state.peripherals_complete().map_err(|err| anyhow!("IMUError: {:?}", err))?;

    // Connect to the Wi-Fi network
    log::info!("SSID: {}", CONFIG.wifi_ssid);
    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs.clone()))?,
        sys_loop.clone(),
    )?;
    link_state.peripherals_complete().map_err(|err| anyhow!("LinkError: {:?}", err))?;

    connect_wifi(&mut wifi)?;
    log::info!("IP: {}", wifi.wifi().sta_netif().get_ip_info()?.ip);

    let mqtt_url: String = format!("mqtt://{}:{}", CONFIG.mqtt_host, CONFIG.mqtt_port);
    let (mut client, mut conn) = EspMqttClient::new(
        &mqtt_url,
        &MqttClientConfiguration {
            client_id: Some(CONFIG.mqtt_id),
            password: Some(CONFIG.mqtt_pass),
            username: Some(CONFIG.mqtt_user),
            //reconnect_timeout: Some(Duration::from_millis(200)),
            ..Default::default()
        },
    )?;

    // Background task for handling MQTT events
    let observer = link_state.get_observer();
    std::thread::Builder::new()
        //.stack_size(8192)
        .name(String::from("mqtt_ev"))
        .spawn(move || -> Result<()> {
            log::info!("MQTT Listening for messages");
            while let Ok(event) = conn.next() {
                match event.payload() {
                    EventPayload::Connected(_) => {
                        link_state.connected().map_err(|err| anyhow!("LinkError: {:?}", err))?;
                        log::info!("Connected to broker!");
                    },
                    EventPayload::Disconnected => {
                        link_state.disconnected().map_err(|err| anyhow!("LinkError: {:?}", err))?;
                        log::info!("Disconnected from broker!");
                    },
                    EventPayload::Published(_) => {
                        // Do nothing with this event.
                        continue;
                    },
                    EventPayload::Error(error) => {
                        log::error!("[MQTT] Error: {:?}", error);
                        break;
                    },
                    _ => {
                        log::info!("[MQTT] Event: {:?}", event.payload());
                    }
                }
            }
            log::warn!("Connection closed");
            Ok(())
        })?;

    loop {
        let st = observer.lock().unwrap();
        if *st == ConnectionStatus::Connected {
            break;
        }
        else {
            std::thread::sleep(Duration::from_millis(100));
            log::info!("Waiting for connection to broker...");
        }
    }

    while let Err(error) = client.subscribe("commands", QoS::AtLeastOnce) {
        log::warn!("MQTT error: {:?}", error);
        std::thread::sleep(Duration::from_millis(100));
    }
    log::info!("Subscribed to topic!");

    // Background task for immediate sending of samples over MQTT
    let (tx, rx) = channel::<Vec<u8>>();
    std::thread::Builder::new()
        //.stack_size(8192)
        .name(String::from("mqtt_q"))
        .spawn(move || {
            log::info!("Awaiting samples to send");
            let event_topic = format!("{}/event", CONFIG.mqtt_id);
            while let Ok(payload) = rx.recv() {
                if let Err(e) = client.publish(&event_topic,
                                                         QoS::AtLeastOnce,
                                                  false,
                                                         payload.as_slice()) {
                    log::warn!("Error sending sample! {e:?}");
                }
            }
            log::info!("MQTT thread closing...");
        })?;

    let mut id = 1u32;
    let mut last = Instant::now();
    let mut analysis = Analysis::default();
    let mut direction: Option<MovementDirection> = None;
    loop {
        notification.wait(esp_idf_svc::hal::delay::BLOCK);
        flag_acquire.set_high()?;
        /* Getting unscaled readings:
        let all = imu.unscaled_all::<[i16; 3]>()
        */
        // TODO read up on the "turbofish" operator below
        let all = imu.all::<[f32; 3]>().map_err(|err| anyhow!("Error: {:?}", err))?;
        let now = Instant::now();
        flag_acquire.set_low()?;
        let imu_gyro = FusionVector::new(all.gyro[0], all.gyro[1],all.gyro[2]) * (180. / core::f32::consts::PI);
        let imu_accel = FusionVector::new(all.accel[0],all.accel[1],all.accel[2]) * (1. / mpu9250::G);
        tracker.update(now, imu_accel, imu_gyro);

        let new_direction = analysis.add_measurement(tracker.linear_accel);
        if id % 50 == 0 {
            if let Some(dir) = new_direction {
                println!("{} {:?}", id, dir);
		        tx.send(vec![0x30 + dir.as_payload()])?;
            }
        }
        id += 1;
    }
}

fn connect_wifi(wifi: &mut BlockingWifi<EspWifi<'static>>) -> Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: CONFIG.wifi_ssid.parse().map_err(|err| anyhow!("Error: {:?}", err))?,
        password: CONFIG.wifi_psk.parse().map_err(|err| anyhow!("Error: {:?}", err))?,
        auth_method: AuthMethod::WPA2Personal,
        ..Default::default()
    });
    wifi.set_configuration(&wifi_configuration)?;
    log::info!("CFG: {:?}", wifi_configuration);

    wifi.start()?;
    log::info!("Wifi started? {}", wifi.is_started()?);

    /* WiFi environment info
    let caps = wifi.get_capabilities()?;
    log::info!("Capabilities {:?}", caps);
    if let Ok(net) = wifi.scan() {
        for ap in net {
            log::info!("Available: {:?}", ap);
        }
    }
    */

    log::info!("Connecting to Wifi...");
    loop {
        match wifi.connect() {
            Ok(_) => break,
            Err(e) => {
                log::warn!("Could not connect ({:?})! Attempting again...", e);
            }
        }
    }
    log::info!("Wifi connected");

    wifi.wait_netif_up()?;
    log::info!("Wifi enumerated");

    Ok(())
}

