use core::time::Duration;
use std::time::Instant;
use anyhow::Result;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    nvs::EspDefaultNvsPartition,
    mqtt::client::*
};
use embedded_hal_bus::i2c;
use core::cell::RefCell;
use esp_idf_svc::hal::{
    delay::FreeRtos,
    gpio::PinDriver,
    gpio::{Gpio20, Gpio21, Output},
    i2c::{I2cConfig, I2cDriver},
    peripherals::Peripherals,
    units::FromValueType,
};
//use esp_idf_svc::sys::EspError;
use esp_idf_svc::timer::EspTaskTimerService;
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};
use mpu6050::{
    Mpu6050,
    Mpu6050Error,
    device::{ AccelRange, GyroRange, ACCEL_HPF },
    PI_180,
};
use imu_fusion::{Fusion, FusionAhrsSettings, FusionVector};

use ssd1306::{prelude::*, I2CDisplayInterface, Ssd1306};
use embedded_graphics::{
    mono_font::{ascii::FONT_6X10, MonoTextStyleBuilder},
    pixelcolor::BinaryColor,
    prelude::*,
    text::{Baseline, Text},
};
use embedded_graphics::mono_font::MonoTextStyle;
use serde::Serialize;
use ssd1306::mode::BufferedGraphicsMode;

//use rand::prelude::*;

// The constant `CONFIG` is auto-generated by `toml_config`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("localhost")]
    mqtt_host: &'static str,
    #[default("1883")]
    mqtt_port: &'static str,
    #[default("")]
    mqtt_user: &'static str,
    #[default("")]
    mqtt_pass: &'static str,
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

#[derive(Debug, serde::Serialize)]
pub struct Measurement {
    ts: f32,
    acc_x: f32,
    acc_y: f32,
    acc_z: f32,
    roll: f32,
    pitch: f32,
    yaw: f32,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise, some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    let i2c_config = I2cConfig::new().baudrate(400.kHz().into());
    let sda_imu = peripherals.pins.gpio1;
    let scl_imu = peripherals.pins.gpio0;
    let i2c = I2cDriver::new(peripherals.i2c0, sda_imu, scl_imu, &i2c_config)?;
    let i2c_ref_cell = RefCell::new(i2c);

    let mut flag_total = PinDriver::output(peripherals.pins.gpio21)?;
    let mut flag_compute = PinDriver::output(peripherals.pins.gpio20)?;
    flag_total.set_low()?;
    flag_compute.set_low()?;

    let interface = I2CDisplayInterface::new(i2c::RefCellDevice::new(&i2c_ref_cell));
    /*
    let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate180)
        .into_buffered_graphics_mode();
    display.init().unwrap();
    */

    let mut delay = FreeRtos;
    let i2c_for_imu = i2c::RefCellDevice::new(&i2c_ref_cell);
    let mut mpu = Mpu6050::new(i2c_for_imu);

    /* Supply chain issue:
     * https://forum.arduino.cc/t/mpu-6050-a-module-problems-who-am-i-reports-0x98-not-0x68-as-it-should-fake-mpu-6050/861956/20
     */
    match mpu.init(&mut delay) {
        Ok(_) => (),
        Err(error) => match error {
            Mpu6050Error::I2c(_) => log::error!("I2C initialization failed."),
            Mpu6050Error::InvalidChipId(read) => log::warn!("Maybe counterfeit chip? GottenID {:#x}.", read),
        }
    };
    mpu.set_accel_range(AccelRange::G4).unwrap();
    mpu.set_gyro_range(GyroRange::D250).unwrap();
    mpu.set_accel_hpf(ACCEL_HPF::_RESET).unwrap();

    /*
    let text_style = MonoTextStyleBuilder::new()
        .font(&FONT_6X10)
        .text_color(BinaryColor::On)
        .build();

    let base_point = Point::zero();
    let msg = format!("SSID: {}", CONFIG.wifi_ssid);
    let mut base_point = display_msg(&mut display, text_style, msg, base_point);
    */

    // Connect to the Wi-Fi network
    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs.clone()))?,
        sys_loop.clone(),
    )?;
    connect_wifi(&mut wifi)?;
    let connected = wifi.is_connected().unwrap();

    /*
    base_point.x = 0;
    let msg = format!("Connected? {:?}", connected);
    let mut base_point = display_msg(&mut display, text_style, msg, base_point);
    */

    /*
    if connected {
        let msg = format!("IP: {}", wifi.wifi().sta_netif().get_ip_info().unwrap().ip);
        base_point.x = 0;
        let mut _base_point = display_msg(&mut display, text_style, msg, base_point);
    }
    */

    let mqtt_url: String = format!("mqtt://{}:{}", CONFIG.mqtt_host, CONFIG.mqtt_port);
    let (mut client, mut conn) = mqtt_create(&mqtt_url, CONFIG.mqtt_user, CONFIG.mqtt_pass)?;

    std::thread::Builder::new()
        .stack_size(6000)
        .spawn(move || {
            log::info!("MQTT Listening for messages");
            while let Ok(event) = conn.next() {
                log::info!("[Queue] Event: {}", event.payload());
            }
            log::info!("Connection closed");
        })
        .unwrap();

    const IMU_SAMPLE_PERIOD: Duration = Duration::from_millis(5);
    const IMU_SAMPLE_FREQ: f32 = 1000_f32 / IMU_SAMPLE_PERIOD.subsec_millis() as f32;
    let ahrs_settings = FusionAhrsSettings::new();
    let mut fusion = Fusion::new(IMU_SAMPLE_FREQ as u32, ahrs_settings);
    let mut pos = FusionVector::zero();
    let mut vel = FusionVector::zero();
    let timer_service = EspTaskTimerService::new().unwrap();
    let start_time = Instant::now();
    let callback_timer = timer_service.timer(move || acq_cmp(
        &mut mpu,
        &mut fusion,
        start_time,
        &IMU_SAMPLE_PERIOD,
        &mut pos, &mut vel,
        &mut client,
        &mut flag_compute,
        &mut flag_total,
    ))?;
    callback_timer.every(IMU_SAMPLE_PERIOD).unwrap();

    loop {
        FreeRtos::delay_ms(2000);
    }
}

fn acq_cmp(
    mpu: &mut Mpu6050<I2cDriver>,
    fusion: &mut Fusion,
    start_time: Instant,
    sampling_period: &Duration,
    pos_vector: &mut FusionVector,
    vel_vector: &mut FusionVector,
    mqtt_c: &mut EspMqttClient,
    flag_compute: &mut PinDriver<Gpio20, Output>,
    flag_total: &mut PinDriver<Gpio21, Output>,
) {
    flag_total.set_high().unwrap();
    flag_compute.set_high().unwrap();
    let ts = start_time.elapsed().as_secs_f32();

    // Gets acceleration in units of earth gravity
    let acc = mpu.get_acc().unwrap();
    // Gets angular rotation in degrees/sec
    let gyr = mpu.get_gyro().unwrap() / PI_180;

    let gyro_vector = FusionVector::new(gyr.x, gyr.y, gyr.z);
    let acceleration_vector = FusionVector::new(acc.x, acc.y, acc.z);
    fusion.update_no_mag(gyro_vector, acceleration_vector, ts);
    // Gets heading in units of degrees
    let euler = fusion.euler();
    let earth_acc = fusion.earth_acc();
    *vel_vector += earth_acc * 9.81 * sampling_period.as_secs_f32();
    *pos_vector += *vel_vector * sampling_period.as_secs_f32();
    flag_compute.set_low().unwrap();

    let meas = Measurement {
        ts: ts,
        acc_x: earth_acc.x,
        acc_y: earth_acc.y,
        acc_z: earth_acc.z,
        pitch: euler.angle.pitch,
        roll: euler.angle.roll,
        yaw: euler.angle.yaw,
    };
    const TOPIC: &str = "meas";
    let payload = serde_json::json!(meas).to_string();
    mqtt_c.enqueue(TOPIC, QoS::AtMostOnce, false, payload.as_bytes()).unwrap();
    
    log::info!("Published data");
    flag_total.set_low().unwrap();
}

fn display_msg(display: &mut Ssd1306<I2CInterface<I2cDriver>, DisplaySize128x64, BufferedGraphicsMode<DisplaySize128x64>>,
               text_style: MonoTextStyle<BinaryColor>,
               msg: String,
               point: Point,
) -> Point {
    let t = Text::with_baseline(&msg, point, text_style, Baseline::Top);
    t.draw(display).unwrap();
    display.flush().unwrap();
    t.bounding_box().bottom_right().unwrap()
}


fn connect_wifi(wifi: &mut BlockingWifi<EspWifi<'static>>) -> Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: CONFIG.wifi_ssid.parse().unwrap(),
        password: CONFIG.wifi_psk.parse().unwrap(),
        auth_method: AuthMethod::WPAWPA2Personal,
        channel: None,
        ..Default::default()
    });
    wifi.set_configuration(&wifi_configuration)?;
    log::info!("CFG: {:?}", wifi_configuration);

    wifi.start()?;
    log::info!("Wifi started? {}", wifi.is_started()?);

    /*
    let caps = wifi.get_capabilities()?;
    log::info!("Capabilities {:?}", caps);

    if let Ok(net) = wifi.scan() {
        for ap in net {
            log::info!("Available: {:?}", ap);
        }
    }
    */

    wifi.connect()?;
    log::info!("Wifi connected");

    wifi.wait_netif_up()?;
    log::info!("Wifi netif up");

    Ok(())
}

fn mqtt_create(
    url: &str,
    client_id: &str,
    password: &str,
) -> Result<(EspMqttClient<'static>, EspMqttConnection)> {
    let (mqtt_client, mqtt_conn) = EspMqttClient::new(
        url,
        &MqttClientConfiguration {
            client_id: Some(client_id),
            password: Some(password),
            username: Some(client_id),
            ..Default::default()
        },
    )?;

    Ok((mqtt_client, mqtt_conn))
}
